import { IdP, TargetType } from './types';
import {
    targetStringExample,
    TargetSummary,
} from './utils';
import { ConfigService } from './config.service/config.service';
import { MixpanelService } from './mixpanel.service/mixpanel.service';
import { checkVersionMiddleware } from './middlewares/check-version-middleware';
import { EnvironmentDetails} from './http.service/http.service.types';
import { Logger } from './logger.service/logger';
import { LoggerConfigService } from './logger-config.service/logger-config.service';
import { KeySplittingService } from '../webshell-common-ts/keysplitting.service/keysplitting.service';

// Handlers
import { initMiddleware, oAuthMiddleware, mixedPanelTrackingMiddleware, fetchDataMiddleware } from './handlers/middleware.handler';
import { sshProxyConfigHandler } from './handlers/ssh-proxy-config.handler';
import { sshProxyHandler } from './handlers/ssh-proxy.handler';
import { loginHandler } from './handlers/login.handler';
import { connectHandler } from './handlers/connect.handler';
import { listTargetsHandler } from './handlers/list-targets.handler';
import { copyHandler } from './handlers/copy.handler';
import { configHandler } from './handlers/config.handler';
import { logoutHandler } from './handlers/logout.handler';

// 3rd Party Modules
import { Dictionary, includes } from 'lodash';
import yargs from 'yargs';


export class CliDriver
{
    private processName: string;
    private configService: ConfigService;
    private keySplittingService: KeySplittingService
    private loggerConfigService: LoggerConfigService;
    private logger: Logger;

    private mixpanelService: MixpanelService;

    private sshTargets: Promise<TargetSummary[]>;
    private ssmTargets: Promise<TargetSummary[]>;
    private dynamicConfigs: Promise<TargetSummary[]>;
    private envs: Promise<EnvironmentDetails[]>;

    // use the following to shortcut middleware according to command
    private noOauthCommands: string[] = ['config', 'login', 'logout'];
    private noMixpanelCommands: string[] = ['config', 'login', 'logout'];
    private noFetchCommands: string[] = ['ssh-proxy-config', 'ssh-proxy', 'config', 'login', 'logout'];

    // available options for TargetType autogenerated from enum
    private targetTypeChoices: string [] = Object.keys(TargetType).map(tt => tt.toLowerCase());

    // Mapping from env vars to options if they exist
    private envMap: Dictionary<string> = {
        'configName': process.env.ZLI_CONFIG_NAME || 'prod',
        'enableKeysplitting': process.env.ZLI_ENABLE_KEYSPLITTING || 'true'
    };

    public start()
    {
        this.processName = process.argv[0];

        yargs(process.argv.slice(2))
            .scriptName('zli')
            .usage('$0 <cmd> [args]')
            .wrap(null)
            .middleware(async (argv) => {
                const initResponse = await initMiddleware(argv);
                this.loggerConfigService = initResponse.loggingConfigService;
                this.logger = initResponse.logger;
                this.configService = initResponse.configService;
                this.keySplittingService = initResponse.keySplittingService;
            })
            .middleware(async () => {
                await checkVersionMiddleware(this.logger);
            })
            .middleware(async (argv) => {
                if(includes(this.noOauthCommands, argv._[0]))
                    return;
                await oAuthMiddleware(this.configService, this.logger);
            })
            .middleware(async (argv) => {
                if(includes(this.noMixpanelCommands, argv._[0]))
                    return;
                this.mixpanelService = mixedPanelTrackingMiddleware(this.configService, argv);
            })
            .middleware((argv) => {
                if(includes(this.noFetchCommands, argv._[0]))
                    return;

                const fetchDataResponse = fetchDataMiddleware(this.configService, this.logger);
                this.dynamicConfigs = fetchDataResponse.dynamicConfigs;
                this.ssmTargets = fetchDataResponse.ssmTargets;
                this.sshTargets = fetchDataResponse.sshTargets;
                this.envs = fetchDataResponse.envs;
            })
            .command(
                'ssh-proxy-config',
                'Generate ssh configuration to be used with the ssh-proxy command',
                (_) => {},
                async (_) => {
                    sshProxyConfigHandler(this.configService, this.logger, this.processName);
                }
            )
            .command(
                'ssh-proxy <host> <user> <port> <identityFile>',
                'ssh proxy command (run ssh-proxy-config command to generate configuration)',
                (yargs) => {
                    return yargs
                        .positional('host', {
                            type: 'string',
                        })
                        .positional('user', {
                            type: 'string',
                        })
                        .positional('port', {
                            type: 'number',
                        })
                        .positional('identityFile', {
                            type: 'string'
                        });
                },
                async (argv) => {
                    await sshProxyHandler(this.configService, this.logger, argv, this.keySplittingService, this.envMap);
                }
            )
            .command(
                'login <provider>',
                'Login through a specific provider',
                (yargs) => {
                    return yargs
                        .positional('provider', {
                            type: 'string',
                            choices: [IdP.Google, IdP.Microsoft]
                        })
                        .option(
                            'mfa',
                            {
                                type: 'string',
                                demandOption: false,
                                alias: 'm'
                            }
                        )
                        .example('login Google', 'Login with Google');
                },
                async (argv) => {
                    await loginHandler(this.configService, this.logger, argv, this.keySplittingService);
                }
            )
        // TODO: https://github.com/yargs/yargs/blob/master/docs/advanced.md#commanddirdirectory-opts
        // <requiredPositional>, [optionalPositional]
            .command(
                'connect <targetType> <targetString>',
                'Connect to a target',
                (yargs) => {
                // you must return the yarg for the handler to have types
                    return yargs
                        .positional('targetType', {
                            type: 'string',
                            choices: this.targetTypeChoices
                        })
                        .positional('targetString', {
                            type: 'string',
                        })
                        .example('connect ssm ssm-user@neat-name', 'SSM connect example')
                        .example('connect ssh dbda775d-e37c-402b-aa76-bbb0799fd775', 'SSH connect example')
                        .example('connect dynamic science@big-science-container-config', 'Connect to a dynamic target example');
                },
                async (argv) => {
                    await connectHandler(this.configService, this.logger, argv, this.mixpanelService, this.dynamicConfigs, this.ssmTargets, this.sshTargets, this.envs);
                }
            )
            .command(
                ['list-targets', 'lt'],
                'List all targets (filters available)',
                (yargs) => {
                    return yargs
                        .option(
                            'targetType',
                            {
                                type: 'string',
                                choices: this.targetTypeChoices,
                                demandOption: false,
                                alias: 't'
                            },
                        )
                        .option(
                            'env',
                            {
                                type: 'string',
                                demandOption: false,
                                alias: 'e'
                            }
                        )
                        .option(
                            'name',
                            {
                                type: 'string',
                                demandOption: false,
                                alias: 'n'
                            }
                        ).option(
                            'showId',
                            {
                                type: 'boolean',
                                default: false,
                                demandOption: false,
                                alias: 'i'
                            }
                        );
                },
                async (argv) => {
                    await listTargetsHandler(this.logger, argv, this.dynamicConfigs, this.ssmTargets, this.sshTargets, this.envs);
                }
            )
            .command(
                'copy <targetType> <source> <destination>',
                'Upload/download a file to target',
                (yargs) => {
                    return yargs
                        .positional('targetType', {
                            type: 'string',
                            choices: ['ssm', 'ssh']
                        })
                        .positional('source', {
                            type: 'string'
                        })
                        .positional('destination', {
                            type: 'string'
                        })
                        .example('copy ssm ssm-user@95b72b50-d09c-49fa-8825-332abfeb013e:/home/ssm-user/file.txt /Users/coolUser/newFileName.txt', 'SSM Download example')
                        .example('copy ssm /Users/coolUser/secretFile.txt ssm-user@neat-target:/home/ssm-user/newFileName', 'SSM Upload example')
                        .example('copy ssh /Users/coolUser/neatFile.txt cool-alias:/home/ssm-user/newFileName.txt', 'SSH Upload example');
                },
                async (argv) => {
                    await copyHandler(this.configService, this.logger, argv, this.dynamicConfigs, this.ssmTargets, this.sshTargets, this.envs);
                }
            )
            .command(
                'config',
                'Returns config file path',
                () => {},
                async () => {
                    await configHandler(this.logger, this.configService, this.loggerConfigService);
                }
            ).command(
                'logout',
                'Deauthenticate the client',
                () => {},
                async () => {
                    await logoutHandler(this.configService, this.logger);
                }
            )
            .option('configName', {type: 'string', choices: ['prod', 'stage', 'dev'], default: this.envMap['configName'], hidden: true})
            .option('debug', {type: 'boolean', default: false, describe: 'Flag to show debug logs'})
            .option('silent', {alias: 's', type: 'boolean', default: false, describe: 'Silence all zli messages'})
            .strict() // if unknown command, show help
            .demandCommand() // if no command, show help
            .help() // auto gen help message
            .epilog(`Note:
 - <targetString> format: ${targetStringExample}
 - TargetStrings only require targetUser for SSM
 - TargetPath can be omitted

For command specific help: zli <cmd> help

Command arguments key:
 - <arg> is required
 - [arg] is optional or sometimes required

Need help? https://app.bastionzero.com/support`)
            .argv; // returns argv of yargs
    }
}